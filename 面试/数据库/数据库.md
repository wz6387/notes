## 1、事务的四大特性

原子性：要么执行，要么不执行

隔离性：所有操作全部执行完前其它会话不能看到过程

一致性：事务签后，数据一致

持久性：一旦事务提交，对数据的改变是永久

## 2、mysql两种存储引擎区别

5.1版本之前默认引擎时MyISAM，之后是innoDB

| 引擎   | 特性                                                         |
| ------ | ------------------------------------------------------------ |
| MyISAM | 不支持事务，不支持外键；它是表级锁，插入数据时，锁定整个表；查表总行数时不需要全表扫描 |
| innodb | 支持事务，支持外键；它是行级锁；查表总行数时，全表扫描       |

一般：不用事务，count计算多是时候适合MyISAM引擎，对可靠性要求高就是innoDB引擎

## 3、mysql索引的底层实现

B+树。B+树每层节点数目很多，层数很少，能尽量减少磁盘IO次数，提高查询效率。

B树与B+树最重要的一个区别是：B+树只有叶子节点存放数据，其余节点用来索引，而B树每个索引节点都有Data域

为什么用B+树，而不用B树？首先，因为B树每个节点都有data域，这无疑增大了节点大小，也就是增加了磁盘IO次数(磁盘IO一次读取的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增加)；而B+树除了叶子节点其它节点不存储数据，节点小，磁盘IO次数少；其次，B+树所有的data域在叶子节点，并且所有叶子节点用指针串起来，这样遍历叶子节点就能获得全部数据，这样就能进行区间访问了。

## 4、数据库中left join、inner join

以A、B两张表为例

select * from A left join B on A.id=B.id

选出A的所有记录，B表中没有的以null代替

inner join A，B有交集的记录

## 5、乐观锁/悲观锁

悲观锁：每次对数据库中数据进行修改时，直接对数据进行加锁以防止并发。之所以叫悲观锁，是因为总是假设最坏的情况，每次读取数据都默认其它线程会更改数据，因此需要加锁操作，当其它线程想要访问数据时，都要阻塞挂起。

乐观锁：假设数据一般情况不会发生冲突，只在提交数据时才检查是否违反数据完整性。使用版本号是最常用的实现方式。通过为数据库表增加一个version字段，当读取数据时，将version一起读出，数据没更新一次，对version值加1。当提交更新时，判断表中对应记录的当前版本信息与第一次取出来的version值比较，如果相等，予以更新，否则认为是过期数据。例如，task表中有三个字段id，value，version，先读task表的数据，得到versionValue；每次更新task表中的value字段时，为了防止冲突，需要这样操作

update task set value = newValue, version = versionValue+1 where version=versionValue;

## 6、最左匹配原则

这是针对索引的。比如两个字段(name，age)建立联合索引，如果where age=12，是没有利用到索引的，这里可以简单的理解为先是对name字段排序，然后对age排序，如果直接查age，这时就没有用到索引。查询条件where name='xxx' and age=xxx，这样就利用到了索引

## 7、char和varchar的区别

+ 最大长度：char最大长度255字符，varchar最大长度65535字符
+ 定长：char是定长的，不足部分用空格填充；varchar是不定长的
+ 空间：char会浪费空间，varchar更节省空间
+ 查找效率：char查找效率高，varchar效率低
+ 尾部空格：char插入时可省略，varchar插入时不会省略，查找时省略

## 8、drop、delete和truncate的区别

+ delete和truncate只删除表的数据，不删除表结构；drop连表数据和表结构一起删除
+ delete是DML语句，操作完以后，如果不想提交事务还可以回滚，truncate和drop是DDL语句，操作完马上生效
+ 执行速度，drop>truncate>delete

不需要一张表时，用drop；想删除部分数据行时，用delete并带上where子句；保留表而删除所有数据时，用truncate

## 9、什么是三范式

第一范式：保证每列的原子性。如果数据库表中所有字段值都是不可分解的原子值，就说明满足了第一范式。例如一张用户信息表

| 编号 | 姓名 | 住址                  |
| ---- | ---- | --------------------- |
| 1    | 张三 | 浙江省杭州市xxx路20号 |
| 2    | 李四 | 浙江省宁波市xxx路30号 |

一般“住址”设计成一个字段就行，但如果经常访问住址中城市的部分，那么就要将住址拆分为“省份”、“城市”、“地址”等多个部分存储，修改后结构如下；

| 编号 | 姓名 | 省份 | 城市 | 地址      |
| ---- | ---- | ---- | ---- | --------- |
| 1    | 张三 | 浙江 | 杭州 | xxx路20号 |
| 2    | 李四 | 浙江 | 宁波 | xxx路30号 |

第二范式：保证一张表只描述一件事情。例如一张表

| 学号 | 姓名 | 年龄 | 课程 | 成绩 | 学分 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 张三 | 18   | 数学 | 90   | 2    |
| 2    | 李四 | 16   | 语文 | 80   | 1    |
| 3    | 张三 | 18   | 语文 | 75   | 1    |
| 4    | 王五 | 17   | 英语 | 85   | 3    |
| 5    | 王五 | 17   | 数学 | 70   | 2    |

这张表描述了两件事：学生信息、课程信息。“学分”完全依赖于“课程名称”，“姓名”与“年龄”完全依赖于“学号”。所以此表必须修改，改后如下：

| 学号 | 姓名 | 年龄 |
| ---- | ---- | ---- |
| 1    | 张三 | 18   |
| 2    | 李四 | 16   |
| 3    | 王五 | 17   |

| 课程 | 学分 |
| ---- | ---- |
| 语文 | 1    |
| 数学 | 2    |
| 英语 | 3    |

| 学号 | 课程 | 成绩 |
| ---- | ---- | ---- |
| 2    | 语文 | 80   |
| 3    | 英语 | 85   |
| 1    | 数学 | 90   |
| 1    | 语文 | 75   |
| 3    | 数学 | 70   |

第三范式：保证每列都和主键直接相关。例如下表

| 学号 | 姓名 | 年龄 | 学院     | 学院地点 | 学院电话 |
| ---- | ---- | ---- | -------- | -------- | -------- |
| 1    | 张三 | 18   | 物电学院 | 11号楼   | 111111   |
| 2    | 李四 | 19   | 物电学院 | 11号楼   | 111111   |
| 3    | 王五 | 19   | 数信学院 | 10号楼   | 333333   |
| 3    | 赵六 | 19   | 数信学院 | 10号楼   | 333333   |
| 5    | 马七 | 18   | 生物学院 | 9号楼    | 555555   |

可以看出“姓名”、“年龄”、“学院”和主键“学号”直接关联，但是“学院地点”和“学院电话”却和“学院”直接关联，因此表要修改

| 学院     | 学院地点 | 学院电话 |
| -------- | -------- | -------- |
| 物电学院 | 11号楼   | 111111   |
| 数信学院 | 10号楼   | 333333   |
| 生物学院 | 9号楼    | 555555   |

| 学号 | 姓名 | 年龄 | 学院     |
| ---- | ---- | ---- | -------- |
| 1    | 张三 | 18   | 物电学院 |
| 2    | 李四 | 19   | 物电学院 |
| 3    | 王五 | 19   | 数信学院 |
| 4    | 赵六 | 19   | 数信学院 |
| 5    | 马七 | 18   | 生物学院 |

## 10、mysql优化

+ 开启查询缓存，优化查询
+ explain你的select查询，这可以帮你分析你的查询语句或表结构的性能瓶颈。explain的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的
+ 当只要一行数据时使用limit 1
+ 为搜索字段建索引
+ 使用enum而不是varchar。如果你有一个字段，比如“性别”， “国家”， “民族”，“状态”，你知道这些字段的取值是有限且固定的，那么你应该用enum
+ Prepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击
+ 垂直分表
+ 选择正确的存储引擎

## 11、索引有哪几种

+ 普通索引：CREATE INDEX index_name ON table_name(col_name);

+ 唯一索引：CREATE UNIQUE INDEX index_name ON table_name(col_name);

+ 主键索引：一个表只能有一个主键，不允许有空值，一般在建表的时候创建主键索引，例如CREATE TABLE `table` (

  `id` int(11) NOT NULL AUTO_INCREMENT ,

  `title` char(255) NOT NULL ,

  PRIMARY KEY (`id`)

  );

+ 全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引配合match against操作使用，而不是一般的where语句加like

## 12、索引的优缺点

优点：

+ 加快数据的检索速度
+ 通过创建唯一索引，保证数据表中每一行数据的唯一性
+ 加速表与表之间的连接
+ 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间

缺点：

+ 索引需要占用物理空间
+ 当对表的数据进行增加、删除和修改时，索引也要动态维护

## 13、聚集索引和非聚集索引

聚集索引：是指数据的物理顺序与列值的逻辑顺序相同，一个表只能有一个聚集索引。比如我们用的新华字典，聚集索引就像是拼音目录，拼音目录对应A-Z的字顺序，和字典中实际存储的字的顺序A-Z是一样的

非聚集索引：索引的逻辑顺序与数据的物理存储顺序不同，一个表可以拥有多个非聚集索引。就像新华字典的偏旁目录，它结构顺序与实际存放顺序不一致

它们的区别在于：通过聚集索引可以找到需要的数据，而通过非聚集索引可以找到对应记录的主键值，再使用主键值通过聚集索引找到需要的数据

## 14、redis基本数据结构

![img](https://img2018.cnblogs.com/blog/1289934/201906/1289934-20190621163930814-1395015700.png)

+ **String字符串类型**。使用命令：get、set、del等，如

```shell
127.0.0.1:6379> set hello 
OK
127.0.0.1:6379> get hello 
"hello"
```

实战场景：

1.缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。

2.计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。

+ **Hash哈希**

  ![img](https://img2018.cnblogs.com/blog/1289934/201906/1289934-20190621232209365-1000366002.png)

使用：所有hash的命令都是 h  开头的   hget 、hset 、 hdel 等

```shell
127.0.0.1:6379> hset user name1 hao
(integer) 1
127.0.0.1:6379> hset user email1 hao@163.com
(integer) 1
127.0.0.1:6379> hgetall user
1) "name1"
2) "hao"
3) "email1"
4) "hao@163.com"
```

实战场景：

1.缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等

+ **链表**

redis使用双向链表，可以通过下标取出对应的value值，左右两边都能插入和删除数据

![img](https://img2018.cnblogs.com/blog/1289934/201906/1289934-20190621233618769-504231907.png)

使用列表的技巧

（1）lpush+lpop=Stack(栈)

（2）lpush+rpop=Queue（队列）

（3）lpush+ltrim=Capped Collection（有限集合）

（4）lpush+brpop=Message Queue（阻塞队列）

常用命令

```shell
LPUSH key value [value ...]　将一个或多个值 value 插入到列表 key 的表头。
RPUSH key value [value ...]　将一个或多个值 value 插入到列表 key 的表尾(最右边)。
LPOP key　移除并返回列表 key 的头元素。
RPOP key　移除并返回列表 key 的尾元素。
LLEN key　返回列表 key 的长度。
BLPOP key [key ...] timeout　它是 LPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。
```

实战：

list 结构的数据查询两端附近的数据性能非常好，适合一些需要获取最新数据的场景，比如取最新的新闻，最近的topN等操作。

+ **Set集合**

集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中 1. 不允许有重复的元素，2.集合中的元素是无序的，不能通过索引下标获取元素，3.支持集合间的操作，可以取多个集合取交集、并集、差集。

![img](https://img2018.cnblogs.com/blog/1289934/201906/1289934-20190622001013515-677922001.png)

使用：命令都是以s开头的 sset 、srem、scard、smembers、sismember

```shell
127.0.0.1:6379> sadd myset hao hao1 xiaohao hao
(integer) 3
127.0.0.1:6379> SMEMBERS myset
1) "xiaohao"
2) "hao1"
3) "hao"
127.0.0.1:6379> SISMEMBER myset hao
(integer) 1
```

实战场景;

1.标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。

2.点赞，或点踩，收藏等，可以放到set中实现

+ **zset集合**

有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性，区别是，有序集合中的元素是可以排序的，它给每个元素设置一个分数，作为排序的依据。

![img](https://img2018.cnblogs.com/blog/1289934/201906/1289934-20190622000959260-539243592.png)

使用： 有序集合的命令都是 以 z 开头  zadd 、 zrange、 zscore

```shell
127.0.0.1:6379> zadd myscoreset 100 hao 90 xiaohao
(integer) 2
127.0.0.1:6379> ZRANGE myscoreset 0 -1
1) "xiaohao"
2) "hao"
127.0.0.1:6379> ZSCORE myscoreset hao
"100"
```

实战场景：

1.排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行

## 15、Innodb是行锁还是表锁

只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁
