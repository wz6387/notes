**1、事务的四大特性**

原子性：要么执行，要么不执行

隔离性：所有操作全部执行完前其它会话不能看到过程

一致性：事务签后，数据一致

持久性：一旦事务提交，对数据的改变是永久

**2、mysql两种存储引擎区别**

5.1版本之前默认引擎时MyISAM，之后是innoDB

| 引擎   | 特性                                                         |
| ------ | ------------------------------------------------------------ |
| MyISAM | 不支持事务，不支持外键；它是表级锁，插入数据时，锁定整个表；查表总行数时不需要全表扫描 |
| innodb | 支持事务，支持外键；它是行级锁；查表总行数时，全表扫描       |

一般：不用事务，count计算多是时候适合MyISAM引擎，对可靠性要求高就是innoDB引擎

**3、mysql索引的底层实现**

B+树。B+树每层节点数目很多，层数很少，能尽量减少磁盘IO次数，提高查询效率。

B树与B+树最重要的一个区别是：B+树只有叶子节点存放数据，其余节点用来索引，而B树每个索引节点都有Data域

为什么用B+树，而不用B树？首先，因为B树每个节点都有data域，这无疑增大了节点大小，也就是增加了磁盘IO次数(磁盘IO一次读取的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增加)；而B+树除了叶子节点其它节点不存储数据，节点小，磁盘IO次数少；其次，B+树所有的data域在叶子节点，并且所有叶子节点用指针串起来，这样遍历叶子节点就能获得全部数据，这样就能进行区间访问了。

**4、数据库中left join、inner join**

以A、B两张表为例

select * from A left join B on A.id=B.id

选出A的所有记录，B表中没有的以null代替

inner join A，B有交集的记录

**5、乐观锁/悲观锁**

悲观锁：每次对数据库中数据进行修改时，直接对数据进行加锁以防止并发。之所以叫悲观锁，是因为总是假设最坏的情况，每次读取数据都默认其它线程会更改数据，因此需要加锁操作，当其它线程想要访问数据时，都要阻塞挂起。

乐观锁：假设数据一般情况不会发生冲突，只在提交数据时才检查是否违反数据完整性。使用版本号是最常用的实现方式。通过为数据库表增加一个version字段，当读取数据时，将version一起读出，数据没更新一次，对version值加1。当提交更新时，判断表中对应记录的当前版本信息与第一次取出来的version值比较，如果相等，予以更新，否则认为是过期数据。例如，task表中有三个字段id，value，version，先读task表的数据，得到versionValue；每次更新task表中的value字段时，为了防止冲突，需要这样操作

update task set value = newValue, version = versionValue+1 where version=versionValue;

**6、最左匹配原则**

这是针对索引的。比如两个字段(name，age)建立联合索引，如果where age=12，是没有利用到索引的，这里可以简单的理解为先是对name字段排序，然后对age排序，如果直接查age，这时就没有用到索引。查询条件where name='xxx' and age=xxx，这样就利用到了索引

**7、char和varchar的区别**

+ 最大长度：char最大长度255字符，varchar最大长度65535字符
+ 定长：char是定长的，不足部分用空格填充；varchar是不定长的
+ 空间：char会浪费空间，varchar更节省空间
+ 查找效率：char查找效率高，varchar效率低
+ 尾部空格：char插入时可省略，varchar插入时不会省略，查找时省略