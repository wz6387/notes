## 递归

**要领**：定义清楚每个递归函数应该要做的事，并相信它能够做好

**例1**：二叉树根节点root和一个目标值sum，返回数中和等于目标值的路径条数，编写pathSum函数

**分析：**首先肯定要遍历二叉树，遍历二叉树的框架放在pathSum中。对于每个节点，他们应该干什么？他们应该看看，自己和脚底下的小弟们包含多少条符合条件的路径。明确了这两个函数，就可以开始写了

```
int pathSum(TreeNode* root, int sum) {
	if(root == NULL) return 0;
	//自己为开头的路径数
	int r = count(root, sum);
	//左边路径总数(相信它能算出来)
	int leftPathSum = pathSum(root->left, sum);
	//右边路径总数(相信它能算出来)
	int rightPathSum = pathSum(root->right, sum);
	return r + leftPathSum + rightPathSum;
}

int count(TreeNode* root, int sum) {
	if(root == NULL) return 0;
	//我自己能不能独当一面，作为一条单独的路径
	int me = (root->val == sum) ? 1 : 0;
	//左边的老弟，你那边能凑几个sum - root->val
	int left = count(root->left, sum - root->val);
	//右边的老弟，你那边能凑几个sum - root->val
	int right = count(root->right, sum - root->val);
	return me + left + right;
}
```

[LeetCode递归专题练习](https://leetcode.com/explore/learn/card/recursion-i/)



**例2：**归并排序，典型的分治算法。分治是一种典型的递归结构，可分为三步：分解->解决->合并

1. 分解原问题为相同的子问题
2. 分解到某一个容易求解的边界后，进行递归求解
3. 将子问题的解合并成原问题的解

```
//伪代码
void merge_sort(数组) {
	if(规模很小容易处理) return;
	merge_sort(左半数组);
	merge_sort(右半数组);
	merge(左半数组，右半数组);
}
```

下面是根据《算法导论》改写的，有几个小细节：

1. 给每一半数组的最后以为添加了哨兵位，理论上是正无穷，用INT_MAX代替
2. 形参begin，end参考c++迭代器，取左闭右开区间，即数组范围是[begin, end)

```
void merge_sort(vector<int>& nums, int begin, int end) {
	if(begin >= end - 1) return;
	//取中值
	int mid = begin + (end - begin)/2;
	//左半排序
	merge_sort(nums, begin, mid);
	//右半排序
	merge_sort(nums, mid, end);
	//结果合并
	merge(nums, begin, mid, end);
}

void merge(vector<int>& nums, int begin, int mid, int end) {
	//分别存储左半数组和右半数组
	vector<int> left(nums.begin()+begin, nums.begin()+mid);
	vector<int> right(nums.begin()+mid, nums.begin()+end);
	//添加哨兵位
	left.push_back(INT_MAX);
	right.push_back(INT_MAX);
	int p = 0, q = 0;
	for(int i = begin; i < end; ++i) {
		if(left[p] < right[q]) {
			nums[i] = left[p++];
		} else {
			nums[i] = right[q++];
		}
	}
}
```

[LeeCode分治算法专项练习](https://leetcode.com/tag/divide-and-conquer/)

