![img](https://pic4.zhimg.com/v2-297f02984ce77328b456cef5f7699d0f_r.jpg)



**1、epoll和select的区别**

select 的底层原理是遍历所有注册的I/O事件，找出准备好的的I/O事件。
而 epoll 则是由内核主动通知哪些I/O事件需要处理，不需要用户线程主动去反复查询，因此大大提高了事件处理的效率。

+ *select* 
  - 单个进程可监听的端口有限，32位机默认是1024个
  - 对socket采用轮询方法，效率较低。当套接字较多时，每次都要遍历所有套接字，通过FD_ISSET判断是否活跃，来完成调度
  - 需要维护一个存放fd的数据结构，这样在用户空间和内核空间传递时复制开销大
+ *poll*与select的区别在于它没有最大连接数的限制，因为它是基于链表存储

​       int poll(struct pollfd fds[], nfds_t nfds, int timeout)；另外与select不同的是，调用poll函数后，不会清空fds这个数组，而select会清空描述符集合，导致每次调用select前都必须把描述符重新加入到待检测集合中

+ *epoll*也没有最大连接数的限制，它只返回就绪的fd，它有两种工作模式
  - 水平触发(LT)：默认模式，当epoll_wait检测到描述符事件就绪并通知应用程序时，应用程序可以不立即处理事件，下次调用epoll_wait时，会再次通知事件
  - 边缘触发(ET)：当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。

**2、epoll原理**

+ 调用epoll_create，创建红黑树和就绪链表。红黑树用于存储epoll_ctl传来的socket，链表用于存储准备就绪的事件
+ 调用epoll_ctl，将socket添加到红黑树上，并给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到就绪列表中
+ 调用epoll_wait，观察就绪链表中有没有数据。有数据就返回，没有数据就sleep

