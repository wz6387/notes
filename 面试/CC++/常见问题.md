# 1、虚函数

c++中虚函数是通过虚函数表实现的，虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，一个类的所有实例都共享同一张虚函数表

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing4.jpg)

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable3.JPG)

# 2、基类的析构函数一般写成虚函数的原因？

如果析构函数不写成虚函数，当删除指向子类的父类指针时，只会调用父类的析构函数而不会调用子类的析构函数，就会造成内存泄漏

# 3、构造函数为什么一般不定义为虚函数？

虚函数的调用需要虚指针，而在构造一个对象时，对象还未创建成功，因此还没有虚指针，自然不能通过虚指针调用构造函数了。

# 4、在构造函数或析构函数调用虚函数会怎么样？

在构造函数中调用虚函数，由于当前对象没有构造完成，此时调用的虚函数指向的是基类的实现方式

在析构函数中调用虚函数，此时调用的是子类的函数实现方式

# 5、介绍C++所有构造函数

主要有三种：默认构造函数、重载构造函数和拷贝构造函数

+ 默认构造函数是当类没有实现构造函数时，编译器默认提供的一个构造函数

+ 重载构造函数也称一般构造函数，一个类可以有多个重载构造函数，但需要参数类型或个数不同

+ 拷贝构造函数是发生在对象赋值的时候，书写形式为 BaseA(const BaseA& obj)。下面三种情况会调用拷贝构造函数

  a. 一个对象以值传递的方式传入函数体；

  b. 一个对象以值传递的方式从函数返回；

  c. 一个对象需要通过另一个对象进行初始化

# 6、虚函数可以是内联函数吗？

虚函数是可以为内联函数的。比如析构函数在类中定义，它是内联函数，析构函数经常也声明为虚函数

# 7、C++智能指针有哪些？

auto_ptr、unique_ptr、shared_ptr和weak_ptr。

+ ~~auto_ptr~~：不建议使用，因为在拷贝和赋值时，原来的对象将失去对指针的所有权

+ unique_ptr：是独占型的智能指针，不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr.下面是错误的

  ```c++
  unique_ptr<T> ptr(new T)
  unique_ptr<T> other = ptr; //错误，不能赋值
  ```

+ shared_ptr：不同的share_ptr对象可以指向同一个指针，内部使用引用计数，当引用计数为0时，将删除指针指向的内存。

  创建shared_ptr的方式：

  a. std::shared_ptr<int> p1(new int());

  b. std::shared_ptr<int> p1 = std::make_shared<int>();

  不能将一个原始指针直接赋值给智能指针，例如下面就是错误的

  std::shared_ptr<int> p = new int(1) ；//编译报错，不允许直接赋值

​       *使用shared_ptr需要注意的问题*：

a. 不要用一个原始指针初始化多个shared_ptr，例如下面这些是错误的

```c++
int* ptr = new int;
shared_ptr<int> p1(ptr);
shared_ptr<int> p2(ptr); //logic error
```

b. 不要在函数实参中创建shared_ptr

```c++
function(shared_ptr<int>(new int), g()); //有缺陷
//因为c++的函数参数计算顺序在不同编译器下可能不一样，一般从右到左，但也有可能从左到右，所以可能的过程是先new int，然后调用g()，如果g()发生异常，而share_ptr还没创建，则int内存泄漏了
```

c. 不要将this通过shared_ptr返回出来，这样可能会导致重复析构，例子如下

```c++
struct A {
    shared_ptr<A> GetSelf() {
        return shared_ptr<A>(this); //don't do this
    }
};
int main(void) 
{
    shared_ptr<A> sp1(new A);
    shared_ptr<A> sp2 = sp1->GetSelf();
    return 0;
}
//this构造了两个智能指针sp1和sp2，它们之间是没有关系的，在离开作用域后this会被两个智能指针各自析构，导致重复析构的错误
```

d. 避免循环引用，如下例

```c++
struct A {
	std::shared_ptr<B> bptr;
	~A() {std::cout << "A is deleted" << std::endl;}
}
struct B {
	std::shared_ptr<A> aptr;
	~B() {std::cout << "B is deleted" << std::endl;}
}
int main()
{
	std::shared_ptr<A> ap(new A);
	std::shared_ptr<B> bp(new B);
	ap->bptr = bp;
	bp->aptr = ap;
	return 0;
}
//测试结果是两个指针A和B都不会删除。循环引用导致ap和bp的引用计数为2，在离开作用域后，ap和bp引用计数减为1，导致两个指针都不会被析构，产生内存泄漏。解决方法是把A和B任何一个成员变量改为weak_ptr。
```

+ weak_ptr：弱引用智能指针，用来监视shared_ptr中的资源是否存在，不会使引用计数+1。

  a. expired()：方法来判断所观测的资源是否已被释放，如

  ```c++
  shared_ptr<init> sp(new int(10));
  weak_ptr<int> wp(sp);
  if(wp.expired()) {
  	std::cout << "weak_ptr无效，所监视的智能指针已被释放";
  } else {
  	std::cout << "weak_ptr有效";
  }
  ```

  b. 通过lock()来获取所监视的shared_ptr

  ```
  std::weak_ptr<int> gw;
  void f() {
  	if(gw.expired()) {
  		std::cout << "gw is expired";
  	} else {
  		auto spt = gw.lock();
  		std::cout << *spt ;
  	}
  }
  ```

  

# 8、c++11的新特性有哪些？

+ auto自动类型推导

+ lambda表达式：定义一个匿名函数，并且可以捕获一定范围内的变量。语法如下：

  [capture] (params) opt -> ret {body;};

+ move语义：将左值转为右值，应用move语义调用构造函数，避免了拷贝，提高了程序性能，例如

  ```c++
  A& A::operator=(const A&& rhs)
  {
  	//转移资源控制权，无需复制
  }
  std::list<std::string> tokens;
  std::list<std::string> t = std::move(tokens);
  ```

+ std::thread和std::mutex

  创建线程方式:  

  ```c++
  void func(int a, double b) {
  	//do work
  }
  
  int main() {
  	std::thread t1(func, 1, 2.0); //方式一
  	std::thread t2(std::bind(func, 1, 2.0));//方式二
  	std::thread t3([](int a, double b){}, 1, 2.0); //方式三
  	t1.join();
  	t2.join();
  	t3.join();
  	return 0;
  }
  
  ```

  互斥量

  ```
  std::mutex mutex_;
  mutex.lock();
  mutex.unlock();
  //一般采用RAII的技术
  std::lock_guard<std::mutex> locker(mutex_);
  ```

# 9、结构体对齐

+ 对齐数=min(指定对齐数，成员自身对齐数），vs默认对齐数为8，linux默认为4
+ 结构体总大小为最大对齐数的整数倍，如果指定了对齐数，则为min(指定对齐数,，最大对齐数)的整数倍
+ 如果是嵌套结构体，可以将嵌套结构体展开进行计算

如：

```c
#pragma pack(2) 
struct my_struct 
{ 
    char a; 
    long double b; 
}; 
#pragma pack()

//sizeof(my_struct) = 10

typedef struct A
{
    double b;
    int i;
    short s;
    char c;
 }A;

typedef struct B
{
    char c;
    int i;
    A a;
}B;

//sizeof(A) = 16
//sizeof(B) = 24

```

# 10、说一下STL的内存管理

STL设计了双层级配置器，第一级配置器直接使用malloc和free，第二级配置器视情况采用不同的策略：当配置区块大于128bytes时，调用第一级配置器；当小于128bytes时，则以内存池管理：内存池维护16个free-lists，各自管理的大小分别为8，16，24，32，40，48，56，64，72，80，88，96，104，112，120，128bytes的小额区块

![image-20220217153410592](C:\Users\A10727\AppData\Roaming\Typora\typora-user-images\image-20220217153410592.png)

 

# 11、placement new

在指定的位置上创建对象，语法为A* p = new (memaddr)A;

既可以在栈上生成对象，也可以在堆上生成对象。生成对象时会自动调用构造函数，但是需要显示调用析构函数，如p->~A();

好处：对象创建速度快；避免内存碎片

# 12、手写shared_ptr

```c++
template<typename T>
class MySharedPtr {
public:
	MySharedPtr(T* p) : cnt_(new int(1)), ptr_(p) {}
	~MySharedPtr() {
		--*cnt_;
		if(*cnt_ == 0) {
			delete ptr_;
			delete cnt_;
		}
	}
	MySharedPtr(const MySharedPtr* p)
		: ptr_(p->ptr)
		, cnt_(p->cnt_)
    {
		++*cnt_;
	}
	MySharedPtr& operator=(const MySharedPtr& other)
	{
		if(this != &other) {
			--*cnt_;
			if(*cnt_ == 0) {
				delete ptr_;
				delete cnt_;
			}
			cnt_ = other.cnt_;
			ptr_ = other.ptr_;
			++*cnt_;
		}
		return *this;
	}
	T* operator->() {return ptr_;}
    T& operator*() return *ptr_;}
private:
	T* ptr_;
	int* cnt_;//必须是指针，因为多个shared_ptr对象共享一个计数器
};
```

# 13、enable_shared_from_this原理

enable_shared_from_this是一个基类，所有从它派生的子类都会有一个shared_from_this()的成员函数。基类中有一个weak_ptr成员变量，该成员变量在创建shared_ptr时初始化，初始化代码如下：

```c++
template<class Y>
explicit shared_ptr( Y * p ): px( p ), pn( p ) 
{
    boost::detail::sp_enable_shared_from_this( this, p, p );
}

template< class X, class Y, class T >
 inline void sp_enable_shared_from_this( boost::shared_ptr<X> const * ppx,
 Y const * py, boost::enable_shared_from_this< T > const * pe )
{
    if( pe != 0 )
    {
        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );
    }
}

template<class X, class Y> void _internal_accept_owner( shared_ptr<X> const * ppx, Y * py ) const
    {
        if( weak_this_.expired() )
        {
            weak_this_ = shared_ptr<T>( *ppx, py );
        }
    }
```

这时，当类对象本身需要自身的shared_ptr时，就可以从这个weak_ptr来生成了:

```c++
shared_ptr<T> shared_from_this()
    {
        shared_ptr<T> p( weak_this_ );
        BOOST_ASSERT( p.get() == this );
        return p;
    }
```

需要小心的是，shared_from_this仅在shared_ptr的构造函数被调用后才能使用，原因是enable_shared_from_this::weak_this并不在构造函数中设置，而是在shared_ptr的构造函数中设置。下面的代码是错误的：

```c++
//错误一：
class D:public boost::enable_shared_from_this<D>
{
public:
    D()
    {
        boost::shared_ptr<D> p=shared_from_this();
    }
};

//错误2
class D:public boost::enable_shared_from_this<D>
{
public:
    void func()
    {
        boost::shared_ptr<D> p=shared_from_this();
    }
};
void main()
{
    D d;
    d.func();
}
```

正确的用法应该是：

```c++
class Test : public std::enable_shared_from_this<Test>        //改进1
{
public:
    //析构函数
    ~Test() { std::cout << "Test Destructor." << std::endl; }
    //获取指向当前对象的指针
    std::shared_ptr<Test> GetObject()
    {
        return shared_from_this();      //改进2
    }
};

int main(int argc, char *argv[])
{
    {
        std::shared_ptr<Test> p( new Test( ));//创建shared_ptr后，shared_from_this才是有效的
        std::shared_ptr<Test> q = p->GetObject();
        std::cout << "p.use_count(): " << p.use_count() << std::endl;
        std::cout << "q.use_count(): " << q.use_count() << std::endl;
    }
    return 0;
}
```

# 14、初始化顺序

分析这段代码的输出：

```c++
class A
{
private:
	int n1;
	int n2;
public:
	A() : n2(0), n1(n2+1) {}
	void Print() {
		std::cout << "n1:" << n1 << ", n2:" << n2 << std::endl;
	}
};

int main()
{
	A a;
	a.Print();
	return 0;
}
```

成员变量初始化顺序只与它们在类中声明顺序有关，与在初始化列表中的顺序无关。n1先声明，所以n1先初始化，此时n2未初始化，所以是个不确定值，然后n2初始化为0

# 15、实现atoi函数

需要考虑几种情况：

+ 指针为NULL
+ 空字符串
+ (+,-)号处理
+ 异常字符处理
+ 溢出时处理
+ 只输入+或-
+ 开头有空格

atoi函数如果有异常，会通过一个全局变量来标识

```c
#define CHECK_LEN(str) \
do { \
	if(strlen(str) == 0) return 0;\
} while(0)
enum {VALID, INVALID};
int gState;

int myAtoI(const char* str)
{
    gState = INVALID;
    if(str == NULL || strlen(str) == 0) {
        return 0;
    }
    //去掉空格
    while(*str == ' ') {
        str++;
    }
    CHECK_LEN(str);
    
    int flag = 1;
    if(*str == '-') {
        flag = -1;
        str++;
    } else if(*str == '+') {
        str++;
    }
    
    int n = 0;
    while(*str != '\0') {
        if(*str >= '0' && *str <= '9') {
            n = n * 10 + flag * (*str - '0');
            if(n > INT_MAX || n < INT_MIN) {
                return 0;
            }
        } else {
            return 0;
        }
        str++;
    }
    gState = VALID;
    return n;
}
```

