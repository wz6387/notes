**1、可以同步非阻塞吗**

可以。举个例子：

+ 在家做饭，米放进去，就站在锅边，傻等饭熟 ——同步阻塞 （单任务按顺序执行）

+ 在家做饭，米放进去，然后回去打游戏，过一会来看一次——同步非阻塞（多任务，定时查看任务执行状态）
+ 用电饭锅，饭熟了自动跳闸。米放进去，傻等饭熟——异步阻塞（没有意义）
+ 电饭锅，米放进去，然后去玩游戏，等跳闸了就去吃饭——异步非阻塞（多任务，自动提交任务执行状态）

**2、内存空间分布**

+ 栈区
+ 堆区
+ 静态区/全局区
  - 初始化的全局变量和静态变量在一个区：data segment
  - 未初始化的在另一个区：bss(block started by symbol)
+ 常量区
+ 代码区

![image-20220217202635553](C:\Users\A10727\AppData\Roaming\Typora\typora-user-images\image-20220217202635553.png)

**3、进程间通信**

+ 管道
  - pipe ：只能在父子进程中通信。int pipe(int filedes[2]);  fd[0]:读管道，fd[1]:写管道
  - 命名管道FIFO：int mkfifo(const char *pathname, mode_t mode);

+ 消息队列

  ```c
  int msgget(key_t key,int flag);
  ```

+ 共享内存

  ```c
  int shmget(key_t key, size_t size, int shmflg);
  ```

+ 信号量

  ```c
  int sem_init(sem_t *sem, int pshared, unsigned int value);
  ```

+ 套接字

+ 信号

**4、Linux虚拟内存空间**

每个进程都拥有4GB的虚拟内存空间，前3GB为用户空间，后1GB为内核空间

![img](https://img-blog.csdnimg.cn/20200521220320797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjMwNzYwMQ==,size_16,color_FFFFFF,t_70)

进程访问的是虚拟内存地址，虚拟地址通过页表转换为物理地址，如果某个虚拟地址在页表中不存在和物理地址的映射，那么系统会发生一次缺页异常，当产生缺页异常时，内核会为进程分配物理页，并建立对应的页表，这之后虚拟地址才映射到了物理地址上。

**5、如何修改文件最大句柄数**

linux默认最大文件句柄数是1024个，并发量较大时，系统会报“too many open files”的错误

+ ulimit -n <文件句柄数>   此方法只对当前shell的进程有效

+ 对所有进程都有效的方法，修改linux系统参数vi /etc/security/limits.conf 添加

  *soft　　nofile　　65536

  *hard　　nofile　　65536

  将最大句柄改为65536

**6、C/C++代码编译过程**

预处理——编译——汇编——链接。预处理先处理各种宏定义，然后交给编译器；编译器编译成.s后缀的汇编代码；汇编代码再通过汇编器形成.o的机器码；最后通过链接器将一个个目标文件链接成一个完整的可执行程序

**7、编码了解么？unicode和utf-8的区别**

编码的本质就是将二进制与符号一一映射，然后通过二进制解析出对应的符号。一开始计算机只存在于欧美，他们理所应当的把英文和二进制做了一个映射表，这就是ASCII码。后来，其他国家也开始使用，需要用到的二进制越来越多，不同国家有不同的编码方式，比如中国的GBK。但是问题是各个国家都不统一，解析起来非常麻烦，因此一个ISO组织就重新高了一个包含所有文字与符号的编码方式，即Unicode。Unicode全称“Universal Multiple-Octet Coded Character Set”，是一个全球统一的符号集，规定了每个符号对应的二进制编码，这个编码长度是不确定的，由字符决定。但是它却没有规定这个符号该如何存储，比如一个英文字符只需要一个字节就可以处理，而一个汉字可能就需要两个字节存储。问题是在编码的时候并不知道这N个字节的二进制到底表示的是一个还是N个符号。于是，utf-8出现了，它提供了一种Unicode的存储方式，它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。

utf-8的编码规则只有两条：

1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，utf-8和ASCII码是相同的

2）对于n字节的符号(n>1)，第一个字节的前n为都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码

具体的unicode编号范围与对应的utf-8二进制格式

![img](https://img-blog.csdnimg.cn/20210410231227946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21haG9vbjQxMQ==,size_16,color_FFFFFF,t_70)

比如：“马”的 Unicode 编号是：0x9A6C，整数编号是 39532，对应第三个范围（2048 - 65535），其格式为：1110XXXX 10XXXXXX 10XXXXXX，39532 对应的二进制是 1001 1010 0110 1100，将二进制填入进入就为：

11101001 10101001 10101100 

**8、大小端模式**

大端：数据的高字节保存在内存的低地址，数据的低字节保存在内存的高地址

小端：数据的高字节保存在内存的高地址，数据的低字节保存在内存的低地址

以unsigned int value = 0x12345678为例，大端模式存储如下：

低地址

---------------

buf[0] (0x12) ——高位字节

buf[1] (0x34)

buf[2] (0x56)

buf[3] (0x78) ——低位字节

--------

高地址



小端模式存储如下：

低地址

-----

buf[0] (0x78) ——低位字节

buf[1] (0x56)

buf[2] (0x34)

buf[3] (0x12) ——高位字节

---

高地址

程序判断方法

```c
//方法一
bool isBig() {
	short x = 0x1122;
	char c = *((char*)(&x));
	if(c == 0x11) {
		return true;
	} else {
		return false;
	}
}

//方法二
//联合体都是从低地址开始存放
union myunion
{
	int a;
	char b;
};
// 如果是大端模式则返回1，小端模式则返回0
int is_big_endian(void)
{
	union myunion u1;
	u1.a = 0x12345678;
    if(0x12 == u1.b) //b始终是在低地址
        return 1;
    else if(0x78 == u1.b)
	    return 0;
}
```

**9、du和df的区别**

du通常针对的是目录，df通常针对的是文件系统。

du：disk usage，统计目录所占磁盘空间大小。逐级进入指定目录的每个子目录并显示目录占用大小

​       -s :   显示目录占用空间总量

​       -h：以K，M，G为单位，提高信息可读性

df：disk free，获取文件系统空间大小
