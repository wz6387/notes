### 快速排序

原理：选择一个关键值为基准值，比基准值小的放在左边，大的放在右边。一般选第一个元素为基准值。

原序列 [12, 20, 5, 16, 15, 1, 30, 45]，i指向12，j指向45，基准值key=12

1、从后面开始向前搜索，找到第一个小于key的值，将值赋给array[i]

2、从前面开始向后搜索，找到第一个大于key的值，将值赋给array[j]

3、重复1、2直到i=j，把基准值赋给当前位置

4、将当前位置作为分界点，递归调用分界点前和分界点后的子数组排序

```c
void quickSort(int* array, int low, int high) {
	if(low >= high) {
		return;
	}
	int key = array[low];
	int i = low, j = high;
	while(i < j) {
		while(i < j && array[j] > key) --j;
		if(i < j) array[i] = array[j];
		while(i < j && array[i] < key) ++i;
		if(i < j) array[j] = array[i];
	}
	array[i] = key;
	quickSort(array, low, i-1);
	quickSort(array, i+1, high);
}
```



### 堆排序

原理：构建一个大顶堆，此时整个序列的最大值就是堆顶的根节点。交换第一个元素和最后一个元素，此时末尾就是最大值，然后将剩余的n-1个元素重新调整成大顶堆。如此反复，就得到一个有序序列。

构建大顶堆从第一个非叶子节点开始(size/2-1)，顺序递减，直到为0调整结束

```

void heapAdjust(int* array, int size, int parent) {
        int child = parent*2 + 1;//左孩子
        if(child >= size) {
                return;
        }
        /*如果存在右孩子，并且右孩子比左孩子大，则取右孩子*/
        if(child+1 < size && array[child+1] > array[child]) {
                child = child + 1;
        }
        /*如果父节点比子节点小，就调整*/
        if(array[parent] < array[child]) {
                std::swap(array[parent], array[child]);
                parent = child;
                heapAdjust(array, size, parent);//对子树调整
        }
}

void heapSort(int* array, int size) {
        if(size <= 0) return;
        /*从非叶子节点开始调整*/
        for(int i = size/2-1; i >= 0; i--) {
                heapAdjust(array, size, i);
        }
        /*交换第一个和最后一个元素*/
        std::swap(array[0], array[size-1]);
        /*重复*/
        heapSort(array, size-1);
}

```















